<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Face Mesh WASM Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }
        .content {
            padding: 30px;
        }
        .status-box {
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            font-weight: 500;
            text-align: center;
        }
        .status-loading {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffc107;
        }
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 2px solid #28a745;
        }
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #dc3545;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 25px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .video-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }
        .video-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .video-box h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        video, canvas {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }
        .info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.95em;
        }
        .info-panel strong {
            color: #667eea;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            opacity: 0.9;
            font-size: 0.9em;
        }
        label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            cursor: pointer;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé≠ MediaPipe Face Mesh WASM</h1>
            <div class="subtitle">Real-time 468 Landmark Face Detection</div>
        </div>

        <div class="content">
            <div id="status" class="status-box status-loading">
                ‚è≥ Loading Face Mesh WASM module...
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="landmarkCount">0</div>
                    <div class="stat-label">Landmarks Detected</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="confidence">0%</div>
                    <div class="stat-label">Confidence</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="fps">0</div>
                    <div class="stat-label">FPS</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgDepth">0.00</div>
                    <div class="stat-label">Avg Depth (Z)</div>
                </div>
            </div>

            <div class="controls">
                <button onclick="startWebcam()" id="startBtn">‚ñ∂Ô∏è Start Webcam</button>
                <button onclick="stopWebcam()" id="stopBtn" disabled>‚èπÔ∏è Stop</button>
                <label>
                    <input type="checkbox" id="showMesh" checked>
                    Show Full Mesh
                </label>
                <label>
                    <input type="checkbox" id="showPoints" checked>
                    Show Landmarks
                </label>
                <label>
                    <input type="checkbox" id="useAttention">
                    Use Attention Model
                </label>
            </div>

            <div class="video-section">
                <div class="video-box">
                    <h3>üìπ Camera Input</h3>
                    <video id="webcam" autoplay playsinline></video>
                    <div class="info-panel" id="cameraInfo">
                        <strong>Status:</strong> <span id="cameraStatus">Waiting...</span>
                    </div>
                </div>
                <div class="video-box">
                    <h3>üé® Face Mesh Output</h3>
                    <canvas id="outputCanvas" width="640" height="480"></canvas>
                    <div class="info-panel" id="meshInfo">
                        <strong>Detection:</strong> <span id="detectionStatus">No face detected</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="face_mesh_wasm.js"></script>
    <script>
        let wasmModule = null;
        let processor = null;
        let webcamStream = null;
        let animationId = null;
        let lastFrameTime = 0;
        let frameCount = 0;

        // Load WASM module
        createFaceMeshModule().then(Module => {
            wasmModule = Module;
            processor = new wasmModule.FaceMeshProcessor();
            processor.initialize(true);

            const statusEl = document.getElementById('status');
            statusEl.className = 'status-box status-success';
            statusEl.innerHTML = `‚úÖ ${processor.getVersion()} - Ready!`;

            document.getElementById('startBtn').disabled = false;
        }).catch(error => {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status-box status-error';
            statusEl.innerHTML = `‚ùå Failed to load module: ${error.message}`;
        });

        async function startWebcam() {
            try {
                const constraints = {
                    video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }
                };

                webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('webcam');
                video.srcObject = webcamStream;

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('cameraStatus').textContent = 'Active';
                document.getElementById('cameraStatus').style.color = '#28a745';

                video.addEventListener('loadeddata', () => {
                    lastFrameTime = performance.now();
                    processFrame();
                });
            } catch (error) {
                alert('Failed to access webcam: ' + error.message);
            }
        }

        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            const video = document.getElementById('webcam');
            video.srcObject = null;

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('cameraStatus').textContent = 'Stopped';
            document.getElementById('cameraStatus').style.color = '#dc3545';

            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset stats
            document.getElementById('landmarkCount').textContent = '0';
            document.getElementById('confidence').textContent = '0%';
            document.getElementById('fps').textContent = '0';
            document.getElementById('detectionStatus').textContent = 'No face detected';
        }

        function processFrame() {
            if (!webcamStream) return;

            const video = document.getElementById('webcam');
            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');

            // Draw video frame
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Process with face mesh
            const useAttention = document.getElementById('useAttention').checked;
            processor.setUseAttention(useAttention);
            
            const result = processor.process(canvas.width, canvas.height, null);

            // Update stats
            if (result.detected) {
                const landmarks = processor.getLandmarks();
                
                document.getElementById('landmarkCount').textContent = result.landmarkCount;
                document.getElementById('confidence').textContent = (result.confidence * 100).toFixed(0) + '%';
                document.getElementById('avgDepth').textContent = processor.getAverageLandmarkZ().toFixed(3);
                document.getElementById('detectionStatus').textContent = result.message;
                document.getElementById('detectionStatus').style.color = '#28a745';

                // Draw face mesh
                if (document.getElementById('showMesh').checked) {
                    drawFaceMesh(ctx, landmarks, canvas.width, canvas.height);
                }

                if (document.getElementById('showPoints').checked) {
                    drawLandmarkPoints(ctx, landmarks, canvas.width, canvas.height);
                }
            } else {
                document.getElementById('detectionStatus').textContent = result.message;
                document.getElementById('detectionStatus').style.color = '#dc3545';
            }

            // Calculate FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFrameTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = now;
            }

            animationId = requestAnimationFrame(processFrame);
        }

        function drawFaceMesh(ctx, landmarks, width, height) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;

            // Draw connections between landmarks (simplified mesh)
            for (let i = 0; i < landmarks.length - 1; i++) {
                const lm1 = landmarks[i];
                const lm2 = landmarks[i + 1];

                ctx.beginPath();
                ctx.moveTo(lm1.x * width, lm1.y * height);
                ctx.lineTo(lm2.x * width, lm2.y * height);
                ctx.stroke();
            }

            ctx.globalAlpha = 1.0;
        }

        function drawLandmarkPoints(ctx, landmarks, width, height) {
            landmarks.forEach((lm, index) => {
                const x = lm.x * width;
                const y = lm.y * height;

                // Color based on depth
                const depthColor = Math.floor((lm.z + 0.1) * 2000);
                ctx.fillStyle = `rgb(${depthColor}, ${255 - depthColor}, 100)`;

                ctx.beginPath();
                ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                ctx.fill();

                // Highlight key landmarks
                if ([1, 33, 133, 263, 362, 61, 291].includes(index)) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // Draw info overlay
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`468 Landmarks`, 10, 25);
        }
    </script>
</body>
</html>
